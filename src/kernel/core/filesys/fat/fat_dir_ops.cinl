#ifndef _FAT_DIR_OPS_CINL
#define _FAT_DIR_OPS_CINL

#include <filesys/vfs.h>
#include <memory/kheap.h>
#include <klib/string.h>
#include <klib/path.h>
#include <klog.h>
#include <errors.h>
#include "fat_priv.h"


static int dir_in_data_clusters_open(file_t *file, uint32_t cluster_no) {
    klog_trace("dir_in_data_clusters_open(cluster=%d)", cluster_no);
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *pf = (struct fat_priv_file_info *)file->filesys_priv_data;

    int err = fat->ops->read_data_cluster(fat, cluster_no, pf->cluster);
    if (err)
        return err;

    klog_debug("dir_in_data_clusters_open()");
    klog_hex16_debug(pf->cluster->buffer, fat->bytes_per_cluster, 0);

    pf->offset = 0;
    pf->size = 0;
    return SUCCESS;
}

static int dir_in_data_clusters_read(file_t *file, struct fat_dir_entry *entry)
{
    klog_trace("dir_in_data_clusters_read()");
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *pf = (struct fat_priv_file_info *)file->filesys_priv_data;
    int err;

    if (pf->offset >= fat->bytes_per_cluster)
    {
        klog_debug("offset %d > than cluster size %d, finding next cluster", pf->offset, fat->bytes_per_cluster);

        // we need to find the next cluster. if end of chain, we
        uint32_t next_cluster_no = 0;
        int err = fat->ops->get_fat_entry_value(fat, pf->sector, pf->cluster->cluster_no, &next_cluster_no);
        if (err)
            return err;
        
        if (fat->ops->is_end_of_chain_entry_value(fat, next_cluster_no))
            return ERR_NO_MORE_CONTENT;

        err = fat->ops->read_data_cluster(fat, next_cluster_no, pf->cluster);
        if (err)
            return err;

        klog_debug("dir_in_data_clusters_read()");
        klog_hex16_debug(pf->cluster->buffer, fat->bytes_per_cluster, 0);

        // reset offset in the buffer, to read the new entries
        pf->offset = 0;
    }

    // otherwise read something, load as needed
    err = extract_dir_entry(pf->cluster->buffer, fat->bytes_per_cluster,
            &pf->offset, entry);
    return err;
}

static int dir_in_data_clusters_close(file_t *file) {
    klog_trace("dir_in_data_clusters_close()");
    // we did not allocate anything, so...
    return SUCCESS;
}



// FAT16 the root dir is stored before the data clusters
static int fat16_root_dir_open(file_t *file)
{
    klog_trace("fat16_root_dir_open()");
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *pf = (struct fat_priv_file_info *)file->filesys_priv_data;

    int err = fat->partition->dev->ops->read(fat->partition->dev,
        fat->root_dir_starting_lba, 0, 
        fat->sectors_per_cluster,
        pf->cluster->buffer);
    if (err)
        return err;

    klog_debug("fat16_root_dir_open(), read %d sectors at LBA %d", fat->sectors_per_cluster, fat->root_dir_starting_lba);
    klog_hex16_debug(pf->cluster->buffer, fat->bytes_per_cluster, 0);

    pf->first_cluster_no = 0;
    pf->cluster->cluster_no = 0;
    pf->cluster->dirty = false;
    pf->offset = 0;
    pf->size = 0;
    return SUCCESS;
}

static int fat16_root_dir_read(file_t *file, struct fat_dir_entry *entry)
{
    klog_trace("fat16_root_dir_read()");
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *pf = (struct fat_priv_file_info *)file->filesys_priv_data;
    int err;

    if (pf->offset >= fat->bytes_per_cluster)
    {
        klog_debug("offset %d > than cluster buffer size %d, loading next cluster of root dir", pf->offset, fat->bytes_per_cluster);

        // FAT12/16 has limited amount of root dir entries, make sure we don't overflow
        int root_dir_bytes = fat->boot_sector->root_entry_count * 32;
        int bytes_read = (pf->cluster->cluster_no + 1) * fat->bytes_per_cluster;
        if (bytes_read >= root_dir_bytes)
            return ERR_NO_MORE_CONTENT;

        // we need to read the next sectors of the root dir, in the cluster buffer
        // despite the root dir not being part of the data clusters area
        pf->cluster->cluster_no++;

        uint32_t lba = fat->root_dir_starting_lba + (pf->cluster->cluster_no * fat->sectors_per_cluster);
        err = fat->partition->dev->ops->read(fat->partition->dev,
                                                  lba,
                                                  0,
                                                  fat->sectors_per_cluster,
                                                  pf->cluster->buffer);
        if (err)
            return err;

        klog_debug("fat16_root_dir_read(), read %d sectors at LBA %d", fat->sectors_per_cluster, lba);
        klog_hex16_debug(pf->cluster->buffer, fat->bytes_per_cluster, 0);

        // reset offset in the buffer, to read the new entries
        pf->offset = 0;
    }

    // otherwise read something, load as needed
    err = extract_dir_entry(pf->cluster->buffer, fat->bytes_per_cluster,
            &pf->offset, entry);
    return err;
}

static int fat16_root_dir_close(file_t *file) {
    klog_trace("fat16_root_dir_close()");
    // we did not allocate anything, so...
    return SUCCESS;
}

// FAT32 the root dir is stored insie the data clusters (as all files and dirs)
static int fat32_root_dir_open(file_t *file)
{
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *pf = (struct fat_priv_file_info *)file->filesys_priv_data;

    return dir_in_data_clusters_open(file, fat->boot_sector->types.fat_32.root_dir_cluster);
}

static int fat32_root_dir_read(file_t *file, struct fat_dir_entry *entry) {
    return dir_in_data_clusters_read(file, entry);
}

static int fat32_root_dir_close(file_t *file) {
    return dir_in_data_clusters_close(file);
}


// loops to find the target_name in the root directory
static int find_entry_in_root_dir(file_t *file, char *target_name, struct fat_dir_entry *entry) {
    klog_trace("find_entry_in_root_dir(target=\"%s\")", target_name);
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *pf = (struct fat_priv_file_info *)file->filesys_priv_data;
    int err;
    bool found = false;

    err = fat->ops->root_dir_open(file);
    if (err)
        return err;

    while (true) {
        err = fat->ops->root_dir_read(file, entry);
        if (err == ERR_NO_MORE_CONTENT)
            break;
        if (err)
            return err;
        if (strcmp(entry->short_name, target_name) == 0) {
            found = true;
            break;
        }
    }

    err = fat->ops->root_dir_close(file);
    if (err)
        return err;

    return found ? SUCCESS : ERR_NOT_FOUND;
}

// loops to find the target_name in a non-root directory
static int find_entry_in_sub_dir(file_t *file, uint32_t dir_cluster_no, char *target_name, struct fat_dir_entry *entry) {
    klog_trace("find_entry_in_sub_dir(cluster=%d, target=\"%s\")", dir_cluster_no, target_name);
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *pf = (struct fat_priv_file_info *)file->filesys_priv_data;
    int err;
    bool found = false;

    err = dir_in_data_clusters_open(file, dir_cluster_no);
    if (err)
        return err;
    while (true) {
        err = dir_in_data_clusters_read(file, entry);
        if (err == ERR_NO_MORE_CONTENT)
            break;
        if (err)
            return err;
        if (strcmp(entry->short_name, target_name) == 0) {
            found = true;
            break;
        }
    }
    err = dir_in_data_clusters_close(file);
    if (err)
        return err;

    return found ? SUCCESS : ERR_NOT_FOUND;
}

// walks a non-empty path, to find the final dir_entry
static int find_entry_for_path(file_t *file, char *path, struct fat_dir_entry *entry)
{
    klog_trace("find_entry_for_path(path=%s)", path);
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *pf = (struct fat_priv_file_info *)file->filesys_priv_data;
    int err;
    bool found = false;

    char *target_name = kmalloc(512);
    int offset = 0;
    err = get_next_path_part(path, &offset, target_name);
    klog_debug("get_next_path_part() -> %d, part=\"%s\"", err, target_name);
    if (err) { 
        kfree(target_name);
        return ERR_BAD_ARGUMENT; // this should not happen, we expect at least one name in the path
    }

    // this is the first time, so look at root folder
    err = find_entry_in_root_dir(file, target_name, entry);
    klog_debug("find_entry_in_root_dir() -> %d", err);
    if (err) {
        kfree(target_name);
        return err;
    }
    
    // now continue to the next path part
    uint32_t cluster_no = entry->first_cluster_no;
    while (true) {
        err = get_next_path_part(path, &offset, target_name);
        klog_debug("get_next_path_part() -> \"%s\"", target_name);
        if (err == ERR_NO_MORE_CONTENT) {
            // that means the last entry was the last one, so we suceeded
            found = true;
            break;
        }
        // otherwise, look for this entry as well
        err = find_entry_in_sub_dir(file, cluster_no, target_name, entry);
        klog_debug("find_entry_in_sub_dir() -> %d", err);
        if (err) {
            kfree(target_name);
            return err;
        }
    }

    kfree(target_name);
    return SUCCESS;
}

static int fat_opendir(char *path, file_t *file)
{
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *pf = kmalloc(sizeof(struct fat_priv_file_info));
    memset(pf, 0, sizeof(struct fat_priv_file_info));

    pf->sector = kmalloc(sizeof(struct sector));
    memset(pf->sector, 0, sizeof(struct sector));
    pf->sector->buffer = kmalloc(fat->bytes_per_sector);
    memset(pf->sector->buffer, 0, fat->bytes_per_sector);
    pf->cluster = kmalloc(sizeof(struct cluster));
    memset(pf->cluster, 0, sizeof(struct cluster));
    pf->cluster->buffer = kmalloc(fat->bytes_per_cluster);
    memset(pf->cluster->buffer, 0, fat->bytes_per_cluster);
    pf->dir_entry = kmalloc(sizeof(struct fat_dir_entry));
    memset(pf->dir_entry, 0, sizeof(struct fat_dir_entry));

    file->filesys_priv_data = pf;

    klog_trace("fat_opendir(fat_type=FAT%d, path=\"%s\")", 
        fat->fat_type == FAT32 ? 32 : (fat->fat_type == FAT16 ? 16 : 12), 
        path);

    pf->is_root_directory = (strlen(path) == 1 && *path == '/');
    if (pf->is_root_directory)
    {
        if (fat->fat_type == FAT12 || fat->fat_type == FAT16) {
            return fat16_root_dir_open(file);
        } else {
            return dir_in_data_clusters_open(file, fat->boot_sector->types.fat_32.root_dir_cluster);
        }
    }
    else
    {
        // follow the path to the dir first
        int err = find_entry_for_path(file, path, pf->dir_entry);
        if (err)
            return err;
        if (!pf->dir_entry->attributes.flags.directory)
            return ERR_NOT_A_DIRECTORY;
        return dir_in_data_clusters_open(file, pf->dir_entry->first_cluster_no);
    }
}

static int fat_readdir(file_t *file, struct dir_entry *dir_entry)
{
    klog_trace("fat_readdir()");
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *pf = (struct fat_priv_file_info *)file->filesys_priv_data;
    struct fat_dir_entry *fat_entry = kmalloc(sizeof(struct fat_dir_entry));
    int err;

    if (pf->is_root_directory && (fat->fat_type == FAT12 || fat->fat_type == FAT16))
        err = fat16_root_dir_read(file, fat_entry);
    else
        err = dir_in_data_clusters_read(file, fat_entry);

    if (err == NO_ERROR) {
        strcpy(dir_entry->short_name, fat_entry->short_name);
        dir_entry->file_size = fat_entry->file_size;
        dir_entry->flags.label = fat_entry->attributes.flags.volume_label;
        dir_entry->flags.dir = fat_entry->attributes.flags.directory;
        dir_entry->flags.read_only = fat_entry->attributes.flags.read_only;
        dir_entry->created.year = fat_entry->created_year;
        dir_entry->created.month = fat_entry->created_month;
        dir_entry->created.day = fat_entry->created_day;
        dir_entry->created.hours = fat_entry->created_hour;
        dir_entry->created.minutes = fat_entry->created_min;
        dir_entry->created.seconds = fat_entry->created_sec;
        dir_entry->modified.year = fat_entry->modified_year;
        dir_entry->modified.month = fat_entry->modified_month;
        dir_entry->modified.day = fat_entry->modified_day;
        dir_entry->modified.hours = fat_entry->modified_hour;
        dir_entry->modified.minutes = fat_entry->modified_min;
        dir_entry->modified.seconds = fat_entry->modified_sec;
    }

    kfree(fat_entry);
    return err;
}

static int fat_closedir(file_t *file) {
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *pf = (struct fat_priv_file_info *)file->filesys_priv_data;
    int err;

    if (pf->is_root_directory && (fat->fat_type == FAT12 || fat->fat_type == FAT16))
        err = fat16_root_dir_close(file);
    else
        err = dir_in_data_clusters_close(file);

    // we must free what we allocated in open()
    kfree(pf->cluster->buffer);
    kfree(pf->cluster);
    kfree(pf->sector->buffer);
    kfree(pf->sector);
    kfree(pf->dir_entry);
    kfree(pf);
    return err;
}


static int fat_mkdir(file_t *file, char *path) {
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *pf = (struct fat_priv_file_info *)file->filesys_priv_data;
    return ERR_NOT_IMPLEMENTED; 
}


#endif