#ifndef _FAT_DIR_OPS_CINL
#define _FAT_DIR_OPS_CINL

#include <filesys/vfs.h>
#include <memory/kheap.h>
#include <klib/string.h>
#include <klib/path.h>
#include <klog.h>
#include <errors.h>
#include "fat_priv.h"

static int fat_opendir(char *path, file_t *file) {
    klog_trace("fat_opendir(\"%s\")", path);
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    bool is_root = strlen(path) == 1 && path[0] == '/';
    int err;

    fat_priv_dir_info *pd = NULL;
    if (is_root) {
        err = fat->ops->priv_dir_open_root(fat, &pd);
        if (err) return err;
        file->filesys_priv_data = pd;
    } else {
        fat_dir_entry entry;
        err = fat->ops->find_path_dir_entry(fat, path, false, &entry);
        if (err) return err;
        if (!entry.attributes.flags.directory)
            return ERR_NOT_A_DIRECTORY;

        err = fat->ops->priv_dir_open_cluster(fat, entry.first_cluster_no, &pd);
        file->filesys_priv_data = pd;
    }

    return SUCCESS;
}

static int fat_readdir(file_t *file, struct dir_entry *dir_entry) {
    klog_trace("fat_readdir()");
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_dir_info *pd = (fat_priv_dir_info *)file->filesys_priv_data;
    
    fat_dir_entry *fat_dir_entry = kmalloc(sizeof(fat_dir_entry));

    int err = fat->ops->priv_dir_entry_read(fat, pd, fat_dir_entry);
    if (err == SUCCESS) {
        klog_debug("fat_readdir(): gotten entry for \"%s\"", fat_dir_entry->short_name);

        strcpy(dir_entry->short_name, fat_dir_entry->short_name);
        fat_dir_entry_to_vfs_dir_entry(fat_dir_entry, dir_entry);
    } else {
        klog_debug("fat_readdir(): priv_dir_entry_read() returned %d", err);
    }

    kfree(fat_dir_entry);
    return err;
}

static int fat_closedir(file_t *file) {
    klog_trace("fat_closedir()");
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_dir_info *pd = (fat_priv_dir_info *)file->filesys_priv_data;

    int err = fat->ops->priv_dir_close(fat, pd);
    return err;
}

static int fat_mkdir(char *path, file_t *file) {
    klog_trace("fat_mkdir(\"%s\")", path);
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_file_info *pf;
    int err = ERR_NOT_IMPLEMENTED; 

    // find directory entry for the path (parent path)
    // create entry

    return err;
}

static int fat_touch(char *path, file_t *file) {
    klog_trace("fat_touch(\"%s\")", path);
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_file_info *pf;
    int err = ERR_NOT_IMPLEMENTED;
    
    // find directory entry for the path (parent path)
    // create entry

    return err;
}

static int fat_unlink(char *path, file_t *file) {
    klog_trace("fat_unlink(\"%s\")", path);
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_file_info *pf;
    int err = ERR_NOT_IMPLEMENTED;
    
    // find dirctory entry
    // invalidate it.

    return err;
}



// --- lower level, accessible through fat->ops



// opening and closing directories
static int priv_dir_open_root(fat_info *fat, fat_priv_dir_info **ppd) {
    klog_trace("priv_dir_open_root()");
    if (fat->fat_type == FAT32)
        return priv_dir_open_cluster(fat, fat->boot_sector->types.fat_32.root_dir_cluster, ppd);

    fat_priv_dir_info *pd = kmalloc(sizeof(fat_priv_dir_info));
    *ppd = pd;
    memset(pd, 0, sizeof(fat_priv_dir_info));
    pd->is_fat16_root = true;
    pd->fat16_root_data.sector_buffer = kmalloc(fat->bytes_per_sector);

    // need to read first sector
    // a sample value is 32 sectors for the root directory.
    // therefore the root dir total size is 16KB.

    int err = fat->partition->dev->ops->read(fat->partition->dev,
        fat->root_dir_starting_lba, 0, 1, pd->fat16_root_data.sector_buffer);
    if (err) return err;

    pd->fat16_root_data.sector_no = 0;
    pd->fat16_root_data.offset_in_sector = 0;
    pd->fat16_root_data.sector_dirty = false;

    klog_debug("open_root_dir(), read %d sectors at LBA %d", 1, fat->root_dir_starting_lba);
    klog_hex16_debug(pd->fat16_root_data.sector_buffer, fat->bytes_per_sector, 0);

    return SUCCESS;
}

static int priv_dir_open_cluster(fat_info *fat, uint32_t cluster_no, fat_priv_dir_info **ppd) {
    klog_trace("priv_dir_open_cluster(cluster=%d)", cluster_no);
    fat_priv_dir_info *pd = kmalloc(sizeof(fat_priv_dir_info));
    *ppd = pd;
    memset(pd, 0, sizeof(fat_priv_dir_info));
    pd->is_fat16_root = false; // explicitly

    // we treat dir contents as file contents
    uint32_t dir_size = fat->bytes_per_cluster; // can be much larger...
    return fat->ops->priv_file_open(fat, cluster_no, dir_size, &(pd->pf));
}

static int priv_dir_read_slot(fat_info *fat, fat_priv_dir_info *pd, uint8_t *buffer32) {
    klog_trace("priv_dir_read_slot()");
    int err;
    if (!pd->is_fat16_root) {
        err = fat->ops->priv_file_read(fat, pd->pf, buffer32, BYTES_PER_DIR_SLOT);
        return (err < 0) ? err : SUCCESS; // we don't care how many bytes we read
    }

    // fat 16 root code here
    if (pd->fat16_root_data.offset_in_sector >= fat->bytes_per_sector) {
        // need to read the next sector
        if (pd->fat16_root_data.sector_no == fat->root_dir_sectors_count - 1)
            return ERR_NO_MORE_CONTENT;
        
        // before reading, write any dirty sector
        if (pd->fat16_root_data.sector_dirty) {
            err = fat->partition->dev->ops->write(fat->partition->dev,
                fat->root_dir_starting_lba + pd->fat16_root_data.sector_no, 
                0, 1, pd->fat16_root_data.sector_buffer);
            if (err < 0) return err;
        }

        // now we can read the next sector
        err = fat->partition->dev->ops->read(fat->partition->dev,
            fat->root_dir_starting_lba + pd->fat16_root_data.sector_no + 1, 
            0, 1, pd->fat16_root_data.sector_buffer);
        if (err < 0) return err;
        pd->fat16_root_data.sector_no += 1;
        pd->fat16_root_data.offset_in_sector = 0;
    }

    // now we can read
    memcpy(buffer32, pd->fat16_root_data.sector_buffer + pd->fat16_root_data.offset_in_sector, BYTES_PER_DIR_SLOT);
    pd->fat16_root_data.offset_in_sector += BYTES_PER_DIR_SLOT;

    return SUCCESS;
}

static int priv_dir_write_slot(fat_info *fat, fat_priv_dir_info *pd, uint8_t *buffer32) {
    klog_trace("priv_dir_write_slot()");
    int err;
    if (!pd->is_fat16_root) {
        err = fat->ops->priv_file_write(fat, pd->pf, buffer32, BYTES_PER_DIR_SLOT);
        return (err < 0) ? err : SUCCESS; // we don't care how many bytes we read
    }

    // fat 16 root code here
    if (pd->fat16_root_data.offset_in_sector >= fat->bytes_per_sector) {
        // need to read the next sector
        if (pd->fat16_root_data.sector_no == fat->root_dir_sectors_count - 1)
            return ERR_NO_SPACE_LEFT;
        
        // before reading, write any dirty sector
        if (pd->fat16_root_data.sector_dirty) {
            err = fat->partition->dev->ops->write(fat->partition->dev,
                fat->root_dir_starting_lba + pd->fat16_root_data.sector_no, 
                0, 1, pd->fat16_root_data.sector_buffer);
            if (err < 0) return err;
        }

        // read next sector
        int err = fat->partition->dev->ops->read(fat->partition->dev,
            fat->root_dir_starting_lba + pd->fat16_root_data.sector_no + 1, 
            0, 1, pd->fat16_root_data.sector_buffer);
        if (err < 0) return err;
        pd->fat16_root_data.sector_no += 1;
        pd->fat16_root_data.offset_in_sector = 0;
    }

    // now we can write
    memcpy(pd->fat16_root_data.sector_buffer + pd->fat16_root_data.offset_in_sector, buffer32, BYTES_PER_DIR_SLOT);
    pd->fat16_root_data.offset_in_sector += BYTES_PER_DIR_SLOT;
    pd->fat16_root_data.sector_dirty = true;

    return SUCCESS;
}

static int priv_dir_get_slot_no(fat_info *fat, fat_priv_dir_info *pd) {
    klog_trace("priv_dir_get_slot_no()");
    if (!pd->is_fat16_root)
        return fat->ops->priv_file_seek(fat, pd->pf, 0, SEEK_CURRENT);

    return (pd->fat16_root_data.sector_no * fat->bytes_per_sector 
        + pd->fat16_root_data.offset_in_sector) / BYTES_PER_DIR_SLOT;
}

static int priv_dir_seek_slot(fat_info *fat, fat_priv_dir_info *pd, int slot_no) {
    klog_trace("priv_dir_seek_slot(slot_no=%d)", slot_no);
    if (!pd->is_fat16_root)
        return fat->ops->priv_file_seek(fat, pd->pf, slot_no * BYTES_PER_DIR_SLOT, SEEK_START);

    // fat 16 root code here
    uint32_t target_sector_no = (slot_no * BYTES_PER_DIR_SLOT) / fat->bytes_per_sector;
    if (target_sector_no != pd->fat16_root_data.sector_no) {
        // we need to read the new sector.
        if (target_sector_no >= fat->root_dir_sectors_count)
            return ERR_NO_MORE_CONTENT;

        // before reading, write any dirty sector
        if (pd->fat16_root_data.sector_dirty) {
            int err = fat->partition->dev->ops->write(fat->partition->dev,
                fat->root_dir_starting_lba + pd->fat16_root_data.sector_no, 
                0, 1, pd->fat16_root_data.sector_buffer);
            if (err) return err;
        }

        // read target sector
        int err = fat->partition->dev->ops->read(fat->partition->dev,
            fat->root_dir_starting_lba + pd->fat16_root_data.sector_no + target_sector_no, 
            0, 1, pd->fat16_root_data.sector_buffer);
        if (err) return err;
        pd->fat16_root_data.sector_no = target_sector_no;
    }

    pd->fat16_root_data.offset_in_sector = (slot_no * BYTES_PER_DIR_SLOT) % fat->bytes_per_sector;

    return SUCCESS;
}

static int priv_dir_close(fat_info *fat, fat_priv_dir_info *pd) {
    klog_trace("priv_dir_close()");
    int err;
    if (pd->is_fat16_root) {
        // before closing, write any dirty sector
        if (pd->fat16_root_data.sector_dirty) {
            int err = fat->partition->dev->ops->write(fat->partition->dev,
                fat->root_dir_starting_lba + pd->fat16_root_data.sector_no, 
                0, 1, pd->fat16_root_data.sector_buffer);
            if (err) return err;
        }

        // free whatever we allocated
        kfree(pd->fat16_root_data.sector_buffer);
    } else {
        err = fat->ops->priv_file_close(fat, pd->pf);
        if (err) return err;
    }
    kfree(pd);
    return SUCCESS;
}

static int priv_dir_entry_read(fat_info *fat, fat_priv_dir_info *pd, fat_dir_entry *entry) {
    klog_trace("priv_dir_entry_read()");
    uint8_t buffer32[BYTES_PER_DIR_SLOT];

    while (true) {
        int err = priv_dir_read_slot(fat, pd, buffer32);
        if (err < 0) return err;

        klog_debug("priv_dir_read_slot() --> slot contents follow");
        klog_hex16_debug(buffer32, BYTES_PER_DIR_SLOT, 0);

        if (is_dir_slot_eof(buffer32))
            return ERR_NO_MORE_CONTENT;

        if (is_dir_slot_deleted(buffer32))
            continue;

        if (is_dir_slot_long_name(buffer32))
            continue; // not supported for now

        entry->short_entry_slot_no = priv_dir_get_slot_no(fat, pd);
        dir_slot_to_entry(buffer32, entry);
        break;
    }

    return SUCCESS;
}

static int priv_dir_entry_invalidate(fat_info *fat, fat_priv_dir_info *pd, fat_dir_entry *entry) {
    klog_trace("priv_dir_entry_invalidate()");
    // write the first byte of the actual entry
    return ERR_NOT_IMPLEMENTED;
}

static int priv_dir_entry_update(fat_info *fat, fat_priv_dir_info *pd, fat_dir_entry *entry) {
    klog_trace("priv_dir_entry_update()");
    // update things like size, date etc.
    // maybe update long file name if same size
    return ERR_NOT_IMPLEMENTED;
}

static int priv_dir_entry_append(fat_info *fat, fat_priv_dir_info *pd, fat_dir_entry *entry) {
    klog_trace("priv_dir_entry_append()");
    // write new entry, along with long file name
    return ERR_NOT_IMPLEMENTED;
}

// find entry in a directory
static int find_entry_in_dir(fat_info *fat, fat_priv_dir_info *pd, uint8_t *name, fat_dir_entry *entry) {
    klog_trace("find_entry_in_dir(name=\"%s\")", name);

    int err = priv_dir_seek_slot(fat, pd, 0);
    if (err) return err;

    while (true) {
        err = priv_dir_entry_read(fat, pd, entry);
        if (err) return err;

        klog_debug("find_entry_in_dir(): gotten entry for \"%s\"", entry->short_name);
        if (strcmp(entry->short_name, name) == 0)
            break;
    }
    return SUCCESS;
}

// find the dir_entry for the containing dir of the path. we can then open it to perform operations.
static int find_path_dir_entry(fat_info *fat,  uint8_t *path, bool containing_dir, fat_dir_entry *entry) {
    klog_trace("find_path_dir_entry(path=\"%s\", containing=%s)", path, containing_dir ? "yes" : "no");
    fat_priv_dir_info *pd = NULL;
    int offset = 0;
    int err = NO_ERROR;
    char *name = kmalloc(strlen(path) + 1);

    int parts_count = count_path_parts(path);
    int parts_needed = containing_dir ? parts_count - 1 : parts_count;
    if (parts_needed == 0) {
        klog_error("find_path_dir_entry(): containing dir for path \"%s\" could be root", path);
        err = ERR_BAD_ARGUMENT;
        goto exit;
    }
    int parts_so_far = 0;

    // start from root (or maybe current working directory?)
    err = priv_dir_open_root(fat, &pd);
    if (err) goto exit;

    while (true) {
        // extract a name from the path
        err = get_next_path_part(path, &offset, name);
        if (err) goto exit;
        parts_so_far++;
        
        // need chunk of user name
        err = find_entry_in_dir(fat, pd, name, entry);
        if (err == ERR_NO_MORE_CONTENT) {
            err = ERR_NOT_FOUND;
            goto exit;
        } else if (err) {
            goto exit;
        }

        // since we found entry of this level, close it
        err = priv_dir_close(fat, pd);
        if (err) goto exit;
        pd = NULL;

        if (parts_so_far == parts_needed) {
            // we are done!
            err = SUCCESS;
            break;
        }
        
        // what we are about to open should be a directory
        if (!entry->attributes.flags.directory) {
            err = ERR_NOT_A_DIRECTORY;
            goto exit;
        }

        // close this and open the next level of directory
        err = priv_dir_open_cluster(fat, entry->first_cluster_no, &pd);
        if (err) goto exit;
    }

    // close any dangling open dir
    if (pd != NULL) {
        err = priv_dir_close(fat, pd);
        if (err) goto exit;
    }

exit:
    if (name)
        kfree(name);
    return err;
}


#endif