#ifndef _FAT_DIR_OPS_CINL
#define _FAT_DIR_OPS_CINL

#include <filesys/vfs.h>
#include <memory/kheap.h>
#include <klib/string.h>
#include <klib/path.h>
#include <klog.h>
#include <errors.h>
#include "fat_priv.h"


static int fat16_root_dir_open(file_t *file)
{
    klog_trace("fat16_root_dir_open()");
    struct fat_info *fat_info = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *file_info = (struct fat_priv_file_info *)file->driver_priv_data;

    int err = fat_info->partition->dev->ops->read(fat_info->partition->dev,
        fat_info->root_dir_starting_lba, 0, 
        fat_info->sectors_per_cluster,
        file_info->cluster_buffer);
    if (err)
        return err;

    klog_debug("fat16_root_dir_open(), read %d sectors at LBA %d", fat_info->sectors_per_cluster, fat_info->root_dir_starting_lba);
    klog_hex16_debug(file_info->cluster_buffer, fat_info->bytes_per_cluster, 0);

    file_info->first_cluster_no = 0;
    file_info->curr_cluster_no = 0;
    file_info->offset = 0;
    file_info->size = 0;
    return SUCCESS;
}

static int fat16_root_dir_read(file_t *file, struct fat_dir_entry *entry)
{
    klog_trace("fat16_root_dir_read()");
    struct fat_info *fat_info = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *file_info = (struct fat_priv_file_info *)file->driver_priv_data;
    int err;

    if (file_info->offset >= fat_info->bytes_per_cluster)
    {
        klog_debug("offset %d > than cluster buffer size %d, loading next cluster of root dir", file_info->offset, fat_info->bytes_per_cluster);

        // FAT12/16 has limited amount of root dir entries, make sure we don't overflow
        int root_dir_bytes = fat_info->boot_sector->root_entry_count * 32;
        int bytes_read = (file_info->curr_cluster_no + 1) * fat_info->bytes_per_cluster;
        if (bytes_read >= root_dir_bytes)
            return ERR_NO_MORE_CONTENT;

        // we need to read the next sectors of the root dir, in the cluster buffer
        // despite the root dir not being part of the data clusters area
        file_info->curr_cluster_no++;

        uint32_t lba = fat_info->root_dir_starting_lba + (file_info->curr_cluster_no * fat_info->sectors_per_cluster);
        err = fat_info->partition->dev->ops->read(fat_info->partition->dev,
                                                  lba,
                                                  0,
                                                  fat_info->sectors_per_cluster,
                                                  file_info->cluster_buffer);
        if (err)
            return err;

        klog_debug("fat16_root_dir_read(), read %d sectors at LBA %d", fat_info->sectors_per_cluster, lba);
        klog_hex16_debug(file_info->cluster_buffer, fat_info->bytes_per_cluster, 0);

        // reset offset in the buffer, to read the new entries
        file_info->offset = 0;
    }

    // otherwise read something, load as needed
    err = extract_next_dir_entry(file_info->cluster_buffer, fat_info->bytes_per_cluster,
            &file_info->offset, entry);
    return err;
}

static int fat16_root_dir_close(file_t *file) {
    klog_trace("fat16_root_dir_close()");
    // we did not allocate anything, so...
    return SUCCESS;
}

static int dir_in_data_clusters_open(file_t *file, uint32_t cluster_no) {
    klog_trace("dir_in_data_clusters_open(cluster=%d)", cluster_no);
    struct fat_info *fat_info = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *file_info = (struct fat_priv_file_info *)file->driver_priv_data;

    uint32_t lba = fat_info->data_clusters_starting_lba + (cluster_no - 2) * fat_info->sectors_per_cluster;
    int err = fat_info->partition->dev->ops->read(fat_info->partition->dev,
        lba, 0,
        fat_info->sectors_per_cluster,
        file_info->cluster_buffer);
    if (err)
        return err;

    klog_debug("dir_in_data_clusters_open(), read %d sectors at LBA %d", fat_info->sectors_per_cluster, lba);
    klog_hex16_debug(file_info->cluster_buffer, fat_info->bytes_per_cluster, 0);

    file_info->curr_cluster_no = cluster_no;
    file_info->offset = 0;
    file_info->size = 0;
    return SUCCESS;
}

static int dir_in_data_clusters_read(file_t *file, struct fat_dir_entry *entry)
{
    klog_trace("dir_in_data_clusters_read()");
    struct fat_info *fat_info = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *file_info = (struct fat_priv_file_info *)file->driver_priv_data;
    int err;

    if (file_info->offset >= fat_info->bytes_per_cluster)
    {
        klog_debug("offset %d > than cluster size %d, finding next cluster", file_info->offset, fat_info->bytes_per_cluster);

        // we need to find the next cluster. if end of chain, we
        uint32_t next_cluster_no = 0;
        int err = get_next_cluster_no(fat_info, 
            file_info->curr_cluster_no, &next_cluster_no, file_info->cluster_buffer);
        if (err)
            return err;
        if (next_cluster_no > fat_info->largest_cluster_no)
            return ERR_NO_MORE_CONTENT;

        // we need to read the next sectors of the root dir, in the cluster buffer
        // despite the root dir not being part of the data clusters area
        file_info->curr_cluster_no = next_cluster_no;

        uint32_t lba = fat_info->root_dir_starting_lba + (file_info->curr_cluster_no * fat_info->sectors_per_cluster);
        err = fat_info->partition->dev->ops->read(fat_info->partition->dev,
            lba, 0, fat_info->sectors_per_cluster, file_info->cluster_buffer);
        if (err)
            return err;

        klog_debug("dir_in_data_clusters_read(), read %d sectors at LBA %d", fat_info->sectors_per_cluster, lba);
        klog_hex16_debug(file_info->cluster_buffer, fat_info->bytes_per_cluster, 0);

        // reset offset in the buffer, to read the new entries
        file_info->offset = 0;
    }

    // otherwise read something, load as needed
    err = extract_next_dir_entry(file_info->cluster_buffer, fat_info->bytes_per_cluster,
            &file_info->offset, entry);
    return err;
}

static int dir_in_data_clusters_close(file_t *file) {
    klog_trace("dir_in_data_clusters_close()");
    // we did not allocate anything, so...
    return SUCCESS;
}


// loops to find the target_name in the root directory
static int find_entry_in_root_dir(file_t *file, char *target_name, struct fat_dir_entry *entry) {
    klog_trace("find_entry_in_root_dir(target=\"%s\")", target_name);
    struct fat_info *fat_info = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *file_info = (struct fat_priv_file_info *)file->driver_priv_data;
    int err;
    bool found = false;

    if (fat_info->fat_type == FAT12 || fat_info->fat_type == FAT16) {
        err = fat16_root_dir_open(file);
        if (err)
            return err;
        while (true) {
            err = fat16_root_dir_read(file, entry);
            if (err == ERR_NO_MORE_CONTENT)
                break;
            if (err)
                return err;
            if (strcmp(entry->short_name, target_name) == 0) {
                found = true;
                break;
            }
        }
        err = fat16_root_dir_close(file);
        if (err)
            return err;
    } else {
        err = dir_in_data_clusters_open(file, fat_info->boot_sector->types.fat_32.root_dir_cluster);
        if (err)
            return err;
        while (true) {
            err = dir_in_data_clusters_read(file, entry);
            if (err == ERR_NO_MORE_CONTENT)
                break;
            if (err)
                return err;
            if (strcmp(entry->short_name, target_name) == 0) {
                found = true;
                break;
            }
        }
        err = dir_in_data_clusters_close(file);
        if (err)
            return err;
    }

    return found ? SUCCESS : ERR_NOT_FOUND;
}

// loops to find the target_name in a non-root directory
static int find_entry_in_sub_dir(file_t *file, uint32_t dir_cluster_no, char *target_name, struct fat_dir_entry *entry) {
    klog_trace("find_entry_in_sub_dir(cluster=%d, target=\"%s\")", dir_cluster_no, target_name);
    struct fat_info *fat_info = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *file_info = (struct fat_priv_file_info *)file->driver_priv_data;
    int err;
    bool found = false;

    err = dir_in_data_clusters_open(file, dir_cluster_no);
    if (err)
        return err;
    while (true) {
        err = dir_in_data_clusters_read(file, entry);
        if (err == ERR_NO_MORE_CONTENT)
            break;
        if (err)
            return err;
        if (strcmp(entry->short_name, target_name) == 0) {
            found = true;
            break;
        }
    }
    err = dir_in_data_clusters_close(file);
    if (err)
        return err;

    return found ? SUCCESS : ERR_NOT_FOUND;
}

// walks a non-empty path, to find the final dir_entry
static int find_entry_for_path(file_t *file, char *path, struct fat_dir_entry *entry)
{
    klog_trace("find_entry_for_path(path=%s)", path);
    struct fat_info *fat_info = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *file_info = (struct fat_priv_file_info *)file->driver_priv_data;
    int err;
    bool found = false;

    char *target_name = kmalloc(512);
    int offset = 0;
    err = get_next_path_part(path, &offset, target_name);
    klog_debug("get_next_path_part() -> %d, part=\"%s\"", err, target_name);
    if (err) { 
        kfree(target_name);
        return ERR_BAD_ARGUMENT; // this should not happen, we expect at least one name in the path
    }

    // this is the first time, so look at root folder
    err = find_entry_in_root_dir(file, target_name, entry);
    klog_debug("find_entry_in_root_dir() -> %d", err);
    if (err) {
        kfree(target_name);
        return err;
    }
    
    // now continue to the next path part
    uint32_t cluster_no = entry->first_cluster_no;
    while (true) {
        err = get_next_path_part(path, &offset, target_name);
        klog_debug("get_next_path_part() -> \"%s\"", target_name);
        if (err == ERR_NO_MORE_CONTENT) {
            // that means the last entry was the last one, so we suceeded
            found = true;
            break;
        }
        // otherwise, look for this entry as well
        err = find_entry_in_sub_dir(file, cluster_no, target_name, entry);
        klog_debug("find_entry_in_sub_dir() -> %d", err);
        if (err) {
            kfree(target_name);
            return err;
        }
    }

    kfree(target_name);
    return SUCCESS;
}

static int fat_opendir(char *path, file_t *file)
{
    struct fat_info *fat_info = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *file_info = kmalloc(sizeof(struct fat_priv_file_info));
    memset(file_info, 0, sizeof(struct fat_priv_file_info));
    file->driver_priv_data = file_info;
    file_info->cluster_buffer = kmalloc(fat_info->bytes_per_cluster);
    file_info->dir_entry = kmalloc(sizeof(struct fat_dir_entry));
    klog_trace("fat_opendir(fat_type=FAT%d, path=\"%s\")", 
        fat_info->fat_type == FAT32 ? 32 : (fat_info->fat_type == FAT16 ? 16 : 12), 
        path);

    file_info->is_root_directory = (strlen(path) == 1 && *path == '/');
    if (file_info->is_root_directory)
    {
        if (fat_info->fat_type == FAT12 || fat_info->fat_type == FAT16) {
            return fat16_root_dir_open(file);
        } else {
            // tested and works
            return dir_in_data_clusters_open(file, fat_info->boot_sector->types.fat_32.root_dir_cluster);
        }
    }
    else
    {
        // follow the path to the dir first
        int err = find_entry_for_path(file, path, file_info->dir_entry);
        if (err)
            return err;
        if (!file_info->dir_entry->attributes.flags.directory)
            return ERR_NOT_A_DIRECTORY;
        return dir_in_data_clusters_open(file, file_info->dir_entry->first_cluster_no);
    }
}

static int fat_readdir(file_t *file, struct dir_entry *dir_entry)
{
    klog_trace("fat_readdir()");
    struct fat_info *fat_info = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *file_info = (struct fat_priv_file_info *)file->driver_priv_data;
    struct fat_dir_entry *fat_entry = kmalloc(sizeof(struct fat_dir_entry));
    int err;

    if (file_info->is_root_directory && (fat_info->fat_type == FAT12 || fat_info->fat_type == FAT16))
        err = fat16_root_dir_read(file, fat_entry);
    else
        err = dir_in_data_clusters_read(file, fat_entry);

    if (err == NO_ERROR) {
        strcpy(dir_entry->short_name, fat_entry->short_name);
        dir_entry->file_size = fat_entry->file_size;
        dir_entry->flags.label = fat_entry->attributes.flags.volume_label;
        dir_entry->flags.dir = fat_entry->attributes.flags.directory;
        dir_entry->flags.read_only = fat_entry->attributes.flags.read_only;
        dir_entry->created.year = fat_entry->created_year;
        dir_entry->created.month = fat_entry->created_month;
        dir_entry->created.day = fat_entry->created_day;
        dir_entry->created.hours = fat_entry->created_hour;
        dir_entry->created.minutes = fat_entry->created_min;
        dir_entry->created.seconds = fat_entry->created_sec;
        dir_entry->modified.year = fat_entry->modified_year;
        dir_entry->modified.month = fat_entry->modified_month;
        dir_entry->modified.day = fat_entry->modified_day;
        dir_entry->modified.hours = fat_entry->modified_hour;
        dir_entry->modified.minutes = fat_entry->modified_min;
        dir_entry->modified.seconds = fat_entry->modified_sec;
    }

    kfree(fat_entry);
    return err;
}

static int fat_closedir(file_t *file) {
    struct fat_info *fat_info = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *file_info = (struct fat_priv_file_info *)file->driver_priv_data;
    int err;

    if (file_info->is_root_directory && (fat_info->fat_type == FAT12 || fat_info->fat_type == FAT16))
        err = fat16_root_dir_close(file);
    else
        err = dir_in_data_clusters_close(file);

    // we must free what we allocated in open()
    kfree(file_info->cluster_buffer);
    kfree(file_info->dir_entry);
    kfree(file_info);
    return err;
}



#endif