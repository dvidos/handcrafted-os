#ifndef _FAT_DIR_OPS_CINL
#define _FAT_DIR_OPS_CINL

#include <filesys/vfs.h>
#include <memory/kheap.h>
#include <klib/string.h>
#include <klib/path.h>
#include <klog.h>
#include <errors.h>
#include "fat_priv.h"


static int dir_in_data_clusters_open(file_t *file, uint32_t cluster_no) {
    klog_trace("dir_in_data_clusters_open(cluster=%d)", cluster_no);
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_file_info *pf = (fat_priv_file_info *)file->filesys_priv_data;

    int err = fat->ops->read_data_cluster(fat, cluster_no, pf->cluster);
    if (err)
        return err;

    klog_debug("dir_in_data_clusters_open()");
    klog_hex16_debug(pf->cluster->buffer, fat->bytes_per_cluster, 0);

    pf->offset = 0;
    pf->size = 0;
    return SUCCESS;
}

static int dir_in_data_clusters_read(file_t *file, fat_dir_entry *entry)
{
    klog_trace("dir_in_data_clusters_read()");
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_file_info *pf = (fat_priv_file_info *)file->filesys_priv_data;
    int err;

    if (pf->offset >= fat->bytes_per_cluster)
    {
        klog_debug("offset %d > than cluster size %d, finding next cluster", pf->offset, fat->bytes_per_cluster);

        // we need to find the next cluster. if end of chain, we
        uint32_t next_cluster_no = 0;
        int err = fat->ops->get_fat_entry_value(fat, pf->sector, pf->cluster->cluster_no, &next_cluster_no);
        if (err)
            return err;
        
        if (fat->ops->is_end_of_chain_entry_value(fat, next_cluster_no))
            return ERR_NO_MORE_CONTENT;

        err = fat->ops->read_data_cluster(fat, next_cluster_no, pf->cluster);
        if (err)
            return err;

        klog_debug("dir_in_data_clusters_read()");
        klog_hex16_debug(pf->cluster->buffer, fat->bytes_per_cluster, 0);

        // reset offset in the buffer, to read the new entries
        pf->offset = 0;
    }

    // otherwise read something, load as needed
    err = extract_dir_entry(pf->cluster->buffer, fat->bytes_per_cluster,
            &pf->offset, entry);
    return err;
}

static int dir_in_data_clusters_close(file_t *file) {
    klog_trace("dir_in_data_clusters_close()");
    // we did not allocate anything, so...
    return SUCCESS;
}



// FAT16 the root dir is stored before the data clusters
static int fat16_root_dir_open(file_t *file)
{
    klog_trace("fat16_root_dir_open()");
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_file_info *pf = (fat_priv_file_info *)file->filesys_priv_data;

    int err = fat->partition->dev->ops->read(fat->partition->dev,
        fat->root_dir_starting_lba, 0, 
        fat->sectors_per_cluster,
        pf->cluster->buffer);
    if (err)
        return err;

    klog_debug("fat16_root_dir_open(), read %d sectors at LBA %d", fat->sectors_per_cluster, fat->root_dir_starting_lba);
    klog_hex16_debug(pf->cluster->buffer, fat->bytes_per_cluster, 0);

    pf->first_cluster_no = 0;
    pf->cluster->cluster_no = 0;
    pf->cluster->dirty = false;
    pf->offset = 0;
    pf->size = 0;
    return SUCCESS;
}

static int fat16_root_dir_read(file_t *file, fat_dir_entry *entry)
{
    klog_trace("fat16_root_dir_read()");
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_file_info *pf = (fat_priv_file_info *)file->filesys_priv_data;
    int err;

    if (pf->offset >= fat->bytes_per_cluster)
    {
        klog_debug("offset %d > than cluster buffer size %d, loading next cluster of root dir", pf->offset, fat->bytes_per_cluster);

        // FAT12/16 has limited amount of root dir entries, make sure we don't overflow
        int root_dir_bytes = fat->boot_sector->root_entry_count * 32;
        int bytes_read = (pf->cluster->cluster_no + 1) * fat->bytes_per_cluster;
        if (bytes_read >= root_dir_bytes)
            return ERR_NO_MORE_CONTENT;

        // we need to read the next sectors of the root dir, in the cluster buffer
        // despite the root dir not being part of the data clusters area
        pf->cluster->cluster_no++;

        uint32_t lba = fat->root_dir_starting_lba + (pf->cluster->cluster_no * fat->sectors_per_cluster);
        err = fat->partition->dev->ops->read(fat->partition->dev,
                    lba, 0, fat->sectors_per_cluster, pf->cluster->buffer);
        if (err)
            return err;

        klog_debug("fat16_root_dir_read(), read %d sectors at LBA %d", fat->sectors_per_cluster, lba);
        klog_hex16_debug(pf->cluster->buffer, fat->bytes_per_cluster, 0);

        // reset offset in the buffer, to read the new entries
        pf->offset = 0;
    }

    // otherwise read something, load as needed
    err = extract_dir_entry(pf->cluster->buffer, fat->bytes_per_cluster,
            &pf->offset, entry);
    return err;
}

static int fat16_root_dir_close(file_t *file) {
    klog_trace("fat16_root_dir_close()");
    // we did not allocate anything, so...
    return SUCCESS;
}

// FAT32 the root dir is stored insie the data clusters (as all files and dirs)
static int fat32_root_dir_open(file_t *file)
{
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_file_info *pf = (fat_priv_file_info *)file->filesys_priv_data;

    return dir_in_data_clusters_open(file, fat->boot_sector->types.fat_32.root_dir_cluster);
}

static int fat32_root_dir_read(file_t *file, fat_dir_entry *entry) {
    return dir_in_data_clusters_read(file, entry);
}

static int fat32_root_dir_close(file_t *file) {
    return dir_in_data_clusters_close(file);
}


// loops to find the target_name in the root directory
static int find_entry_in_root_dir(file_t *file, char *target_name, fat_dir_entry *entry) {
    klog_trace("find_entry_in_root_dir(target=\"%s\")", target_name);
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_file_info *pf = (fat_priv_file_info *)file->filesys_priv_data;
    int err;
    bool found = false;

    err = fat->ops->root_dir_open(file);
    if (err)
        return err;

    while (true) {
        err = fat->ops->root_dir_read(file, entry);
        if (err == ERR_NO_MORE_CONTENT)
            break;
        if (err)
            return err;
        if (strcmp(entry->short_name, target_name) == 0) {
            found = true;
            break;
        }
    }

    err = fat->ops->root_dir_close(file);
    if (err)
        return err;

    return found ? SUCCESS : ERR_NOT_FOUND;
}

// loops to find the target_name in a non-root directory
static int find_entry_in_sub_dir(file_t *file, uint32_t dir_cluster_no, char *target_name, fat_dir_entry *entry) {
    klog_trace("find_entry_in_sub_dir(cluster=%d, target=\"%s\")", dir_cluster_no, target_name);
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_file_info *pf = (fat_priv_file_info *)file->filesys_priv_data;
    int err;
    bool found = false;

    err = dir_in_data_clusters_open(file, dir_cluster_no);
    if (err)
        return err;
    while (true) {
        err = dir_in_data_clusters_read(file, entry);
        if (err == ERR_NO_MORE_CONTENT)
            break;
        if (err)
            return err;
        if (strcmp(entry->short_name, target_name) == 0) {
            found = true;
            break;
        }
    }
    err = dir_in_data_clusters_close(file);
    if (err)
        return err;

    return found ? SUCCESS : ERR_NOT_FOUND;
}

// walks a non-empty path, to find the final dir_entry
static int find_entry_for_path(file_t *file, char *path, fat_dir_entry *entry)
{
    klog_trace("find_entry_for_path(path=%s)", path);
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_file_info *pf = (fat_priv_file_info *)file->filesys_priv_data;
    int err;
    bool found = false;

    char *target_name = kmalloc(512);
    int offset = 0;
    err = get_next_path_part(path, &offset, target_name);
    klog_debug("get_next_path_part() -> %d, part=\"%s\"", err, target_name);
    if (err) { 
        kfree(target_name);
        return ERR_BAD_ARGUMENT; // this should not happen, we expect at least one name in the path
    }

    // this is the first time, so look at root folder
    err = find_entry_in_root_dir(file, target_name, entry);
    klog_debug("find_entry_in_root_dir() -> %d", err);
    if (err) {
        kfree(target_name);
        return err;
    }
    
    // now continue to the next path part
    uint32_t cluster_no = entry->first_cluster_no;
    while (true) {
        err = get_next_path_part(path, &offset, target_name);
        klog_debug("get_next_path_part() -> \"%s\"", target_name);
        if (err == ERR_NO_MORE_CONTENT) {
            // that means the last entry was the last one, so we suceeded
            found = true;
            break;
        }
        // otherwise, look for this entry as well
        err = find_entry_in_sub_dir(file, cluster_no, target_name, entry);
        klog_debug("find_entry_in_sub_dir() -> %d", err);
        if (err) {
            kfree(target_name);
            return err;
        }
    }

    kfree(target_name);
    return SUCCESS;
}

static int fat_opendir(char *path, file_t *file)
{
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_file_info *pf = kmalloc(sizeof(fat_priv_file_info));
    memset(pf, 0, sizeof(fat_priv_file_info));

    pf->sector = kmalloc(sizeof(sector_t));
    memset(pf->sector, 0, sizeof(sector_t));
    pf->sector->buffer = kmalloc(fat->bytes_per_sector);
    memset(pf->sector->buffer, 0, fat->bytes_per_sector);
    pf->cluster = kmalloc(sizeof(cluster_t));
    memset(pf->cluster, 0, sizeof(cluster_t));
    pf->cluster->buffer = kmalloc(fat->bytes_per_cluster);
    memset(pf->cluster->buffer, 0, fat->bytes_per_cluster);
    pf->dir_entry = kmalloc(sizeof(fat_dir_entry));
    memset(pf->dir_entry, 0, sizeof(fat_dir_entry));

    file->filesys_priv_data = pf;

    klog_trace("fat_opendir(fat_type=FAT%d, path=\"%s\")", 
        fat->fat_type == FAT32 ? 32 : (fat->fat_type == FAT16 ? 16 : 12), 
        path);

    pf->is_root_directory = (strlen(path) == 1 && *path == '/');
    if (pf->is_root_directory)
    {
        if (fat->fat_type == FAT12 || fat->fat_type == FAT16) {
            return fat16_root_dir_open(file);
        } else {
            return dir_in_data_clusters_open(file, fat->boot_sector->types.fat_32.root_dir_cluster);
        }
    }
    else
    {
        // follow the path to the dir first
        int err = find_entry_for_path(file, path, pf->dir_entry);
        if (err)
            return err;
        if (!pf->dir_entry->attributes.flags.directory)
            return ERR_NOT_A_DIRECTORY;
        return dir_in_data_clusters_open(file, pf->dir_entry->first_cluster_no);
    }
}

static int fat_readdir(file_t *file, struct dir_entry *dir_entry)
{
    klog_trace("fat_readdir()");
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_file_info *pf = (fat_priv_file_info *)file->filesys_priv_data;
    fat_dir_entry *fat_entry = kmalloc(sizeof(fat_dir_entry));
    int err;

    if (pf->is_root_directory && (fat->fat_type == FAT12 || fat->fat_type == FAT16))
        err = fat16_root_dir_read(file, fat_entry);
    else
        err = dir_in_data_clusters_read(file, fat_entry);

    if (err == NO_ERROR) {
        strcpy(dir_entry->short_name, fat_entry->short_name);
        dir_entry->file_size = fat_entry->file_size;
        dir_entry->flags.label = fat_entry->attributes.flags.volume_label;
        dir_entry->flags.dir = fat_entry->attributes.flags.directory;
        dir_entry->flags.read_only = fat_entry->attributes.flags.read_only;
        dir_entry->created.year = fat_entry->created_year;
        dir_entry->created.month = fat_entry->created_month;
        dir_entry->created.day = fat_entry->created_day;
        dir_entry->created.hours = fat_entry->created_hour;
        dir_entry->created.minutes = fat_entry->created_min;
        dir_entry->created.seconds = fat_entry->created_sec;
        dir_entry->modified.year = fat_entry->modified_year;
        dir_entry->modified.month = fat_entry->modified_month;
        dir_entry->modified.day = fat_entry->modified_day;
        dir_entry->modified.hours = fat_entry->modified_hour;
        dir_entry->modified.minutes = fat_entry->modified_min;
        dir_entry->modified.seconds = fat_entry->modified_sec;
    }

    kfree(fat_entry);
    return err;
}

static int fat_closedir(file_t *file) {
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_file_info *pf = (fat_priv_file_info *)file->filesys_priv_data;
    int err;

    if (pf->is_root_directory && (fat->fat_type == FAT12 || fat->fat_type == FAT16))
        err = fat16_root_dir_close(file);
    else
        err = dir_in_data_clusters_close(file);

    // we must free what we allocated in open()
    kfree(pf->cluster->buffer);
    kfree(pf->cluster);
    kfree(pf->sector->buffer);
    kfree(pf->sector);
    kfree(pf->dir_entry);
    kfree(pf);
    return err;
}


static int fat_mkdir(file_t *file, char *path) {
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_file_info *pf = (fat_priv_file_info *)file->filesys_priv_data;
    int err = ERR_NOT_IMPLEMENTED; 

    // find directory entry for the path (parent path)
    // create entry

    return err;
}

static int fat_touch(char *path, file_t *file) {
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_file_info *pf = (fat_priv_file_info *)file->filesys_priv_data;
    int err = ERR_NOT_IMPLEMENTED;
    
    // find directory entry for the path (parent path)
    // create entry

    return err;
}

static int fat_unlink(char *path, file_t *file) {
    fat_info *fat = (fat_info *)file->partition->filesys_priv_data;
    fat_priv_file_info *pf = (fat_priv_file_info *)file->filesys_priv_data;
    int err = ERR_NOT_IMPLEMENTED;
    
    // find dirctory entry
    // invalidate it.

    return err;
}


/*
    most probably we need something similar to the approach in clusters.cincl.
    Essentially, ability to navigate the clusters of a directory as needed
        also transparently navigate sectors of root directory in FAT16 as well.
    Then, abiltiy to treat the entries in a directory as parts of a file:
    - read an entry (and advance some pointer)
    - remove (invalidate) an entry
    - add an entry at end of table (e.g. to change long file name)
    - update an entry in place (e.g. file size, first cluster no for a new file, update date)
    Let's keep the UCS-2 encoding, maybe we can add english later on.
    Maybe beyond just "priv_fat_file_data", we need "priv_fat_dir_data" type
    Maybe we can treat directories as files with var-length dentries as contents?
        yes, but not the root directory...
*/

static int priv_dir_open_cluster(fat_info *fat, uint32_t cluster_no, fat_priv_dir_info *pd);


// ------------------------------------


// opening and closing directories
static int priv_dir_open_root(fat_info *fat, fat_priv_dir_info *pd) {
    if (fat->fat_type == FAT32)
        return priv_dir_open_cluster(fat, fat->boot_sector->types.fat_32.root_dir_cluster, pd);

    pd = kmalloc(sizeof(fat_priv_dir_info));
    memset(pd, 0, sizeof(fat_priv_dir_info));
    pd->is_fat16_root = true;
    pd->fat16_root_data.sector_buffer = kmalloc(fat->bytes_per_sector);

    // need to read first sector
    // a sample value is 32 sectors for the root directory.

    int err = fat->partition->dev->ops->read(fat->partition->dev,
        fat->root_dir_starting_lba, 0, 1, pd->fat16_root_data.sector_buffer);
    if (err) return err;

    pd->fat16_root_data.sector_no = 0;
    pd->fat16_root_data.offset_in_sector = 0;
    pd->fat16_root_data.sector_dirty = false;

    klog_debug("open_root_dir(), read %d sectors at LBA %d", 1, fat->root_dir_starting_lba);
    klog_hex16_debug(pd->fat16_root_data.sector_buffer, fat->bytes_per_sector, 0);

    return SUCCESS;
}

static int priv_dir_open_cluster(fat_info *fat, uint32_t cluster_no, fat_priv_dir_info *pd) {
    pd = kmalloc(sizeof(fat_priv_dir_info));
    memset(pd, 0, sizeof(fat_priv_dir_info));
    pd->is_fat16_root = false; // explicitly

    // we treat dir contents as file contents
    uint32_t dir_size = fat->bytes_per_cluster; // can be much larger...
    return fat->ops->priv_file_open(fat, cluster_no, dir_size, pd->pf);
}

static int priv_dir_read_slot(fat_info *fat, fat_priv_dir_info *pd, uint8_t *buffer32) {
    if (!pd->is_fat16_root)
        return fat->ops->priv_file_read(fat, pd->pf, buffer32, 32);

    // fat 16 root code here
    if (pd->fat16_root_data.offset_in_sector >= fat->bytes_per_sector) {
        // need to read the next sector
        if (pd->fat16_root_data.sector_no == fat->root_dir_sectors_count - 1)
            return ERR_NO_MORE_CONTENT;
        
        // before reading, write any dirty sector
        if (pd->fat16_root_data.sector_dirty) {
            int err = fat->partition->dev->ops->write(fat->partition->dev,
                fat->root_dir_starting_lba + pd->fat16_root_data.sector_no, 
                0, 1, pd->fat16_root_data.sector_buffer);
            if (err) return err;
        }

        // now we can read the next sector
        int err = fat->partition->dev->ops->read(fat->partition->dev,
            fat->root_dir_starting_lba + pd->fat16_root_data.sector_no + 1, 
            0, 1, pd->fat16_root_data.sector_buffer);
        if (err) return err;
        pd->fat16_root_data.sector_no += 1;
        pd->fat16_root_data.offset_in_sector = 0;
    }

    // now we can read
    memcpy(buffer32, pd->fat16_root_data.sector_buffer + pd->fat16_root_data.offset_in_sector, 32);
    pd->fat16_root_data.offset_in_sector += 32;

    return SUCCESS;
}

static int priv_dir_write_slot(fat_info *fat, fat_priv_dir_info *pd, uint8_t *buffer32) {
    if (!pd->is_fat16_root)
        return fat->ops->priv_file_write(fat, pd->pf, buffer32, 32);

    // fat 16 root code here
    if (pd->fat16_root_data.offset_in_sector >= fat->bytes_per_sector) {
        // need to read the next sector
        if (pd->fat16_root_data.sector_no == fat->root_dir_sectors_count - 1)
            return ERR_NO_MORE_CONTENT;
        
        // before reading, write any dirty sector
        if (pd->fat16_root_data.sector_dirty) {
            int err = fat->partition->dev->ops->write(fat->partition->dev,
                fat->root_dir_starting_lba + pd->fat16_root_data.sector_no, 
                0, 1, pd->fat16_root_data.sector_buffer);
            if (err) return err;
        }

        // read next sector
        int err = fat->partition->dev->ops->read(fat->partition->dev,
            fat->root_dir_starting_lba + pd->fat16_root_data.sector_no + 1, 
            0, 1, pd->fat16_root_data.sector_buffer);
        if (err) return err;
        pd->fat16_root_data.sector_no += 1;
        pd->fat16_root_data.offset_in_sector = 0;
    }

    // now we can write
    memcpy(pd->fat16_root_data.sector_buffer + pd->fat16_root_data.offset_in_sector, buffer32, 32);
    pd->fat16_root_data.offset_in_sector += 32;
    pd->fat16_root_data.sector_dirty = true;

    return SUCCESS;
}

static int priv_dir_seek_slot(fat_info *fat, fat_priv_dir_info *pd, int slot_no) {
    if (!pd->is_fat16_root)
        return fat->ops->priv_file_seek(fat, pd->pf, slot_no * 32, SEEK_START);

    // fat 16 root code here
    uint32_t target_sector_no = (slot_no * 32) / fat->bytes_per_sector;
    if (target_sector_no != pd->fat16_root_data.sector_no) {
        // we need to read the new sector.
        if (target_sector_no >= fat->root_dir_sectors_count)
            return ERR_NO_MORE_CONTENT;

        // before reading, write any dirty sector
        if (pd->fat16_root_data.sector_dirty) {
            int err = fat->partition->dev->ops->write(fat->partition->dev,
                fat->root_dir_starting_lba + pd->fat16_root_data.sector_no, 
                0, 1, pd->fat16_root_data.sector_buffer);
            if (err) return err;
        }

        // read target sector
        int err = fat->partition->dev->ops->read(fat->partition->dev,
            fat->root_dir_starting_lba + pd->fat16_root_data.sector_no + target_sector_no, 
            0, 1, pd->fat16_root_data.sector_buffer);
        if (err) return err;
        pd->fat16_root_data.sector_no = target_sector_no;
    }

    pd->fat16_root_data.offset_in_sector = (slot_no * 32) % fat->bytes_per_sector;

    return SUCCESS;
}

static int priv_dir_close(fat_info *fat, fat_priv_dir_info *pd) {
    int err;
    if (pd->is_fat16_root) {
        // before closing, write any dirty sector
        if (pd->fat16_root_data.sector_dirty) {
            int err = fat->partition->dev->ops->write(fat->partition->dev,
                fat->root_dir_starting_lba + pd->fat16_root_data.sector_no, 
                0, 1, pd->fat16_root_data.sector_buffer);
            if (err) return err;
        }

        // free whatever we allocated
        kfree(pd->fat16_root_data.sector_buffer);
    } else {
        err = fat->ops->priv_file_close(fat, pd->pf);
        if (err) return err;
    }
    kfree(pd);
    return SUCCESS;
}

int read_dir_entry(fat_info *fat, fat_priv_dir_info *pd, fat_dir_entry *entry) {
    uint8_t buffer32[32];

    while (true) {
        int err = priv_dir_read_slot(fat, pd, buffer32);
        // must detect end of content
        // skip invalidated entries
        // collect long names
        // extract actual entries
    }

    return ERR_NOT_IMPLEMENTED;
}

int invalidate_dir_entry(fat_info *fat, fat_priv_dir_info *pd, fat_dir_entry *entry) {
    // write the first byte of the actual entry
    return ERR_NOT_IMPLEMENTED;
}

int update_dir_entry_in_place(fat_info *fat, fat_priv_dir_info *pd, fat_dir_entry *entry) {

    // update things like size, date etc.
    // maybe update long file name if same size
    return ERR_NOT_IMPLEMENTED;
}

int append_dir_entry(fat_info *fat, fat_priv_dir_info *pd, fat_dir_entry *entry) {
    // write new entry, along with long file name
    return ERR_NOT_IMPLEMENTED;
}

// working with paths
int find_named_entry_in_dir(fat_info *fat, fat_priv_dir_info *pd, uint8_t *name, fat_dir_entry *entry) {
    return ERR_NOT_IMPLEMENTED;
}

int find_path_entry(fat_info *fat, fat_priv_dir_info *pd, uint8_t *path, fat_dir_entry *entry) {
    // if caller wants the containing directory, they should split the path.
    return ERR_NOT_IMPLEMENTED;
}





#endif