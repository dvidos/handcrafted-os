#include <errors.h>
#include <klib/string.h>
#include "fat_priv.h"
#include "fat_dir_ops.cinl"
#include "fat_file_ops.cinl"

static int fat_probe(struct partition *partition) {
    klog_trace("FAT probing partition #%d (legacy type 0x%02x)", partition->part_no, partition->legacy_type);

    if (sizeof(fat_boot_sector_t) != 512) {
        klog_error("Boot sector struct would not align with reading of a sector");
        return ERR_NOT_SUPPORTED;
    }
    
    // let's check the first sector of the partition.
    fat_boot_sector_t *boot_sector = kmalloc(sizeof(fat_boot_sector_t));
    memset(boot_sector, 0, sizeof(fat_boot_sector_t));
    int err = partition->dev->ops->read(
        partition->dev, 
        partition->first_sector, 0,
        1,
        (char *)boot_sector
    );
    if (err) {
        klog_debug("Err %d reading first sector of partition", err);
        kfree(boot_sector);
        return err;
    }
    
    if (boot_sector->bootjmp[0] != 0xEB ||
        boot_sector->bytes_per_sector != 512 ||
        boot_sector->number_of_fats != 2 ||
        (boot_sector->total_sectors_16bits == 0 && boot_sector->total_sectors_32bits == 0) ||
        (
            boot_sector->types.fat_12_16.boot_signature != 0x28 &&
            boot_sector->types.fat_12_16.boot_signature != 0x29 && 
            boot_sector->types.fat_32.boot_signature != 0x28 &&
            boot_sector->types.fat_32.boot_signature != 0x29
        ) ||
        boot_sector->bootable_sector_signature != 0xAA55
    ) {
        klog_debug("Does not look like a FAT MBR");
        kfree(boot_sector);
        return ERR_NOT_SUPPORTED;
    }

    // fat_info will allow all future operations
    fat_info *fat = kmalloc(sizeof(fat_info));
    memset(fat, 0, sizeof(fat_info));
    fat->partition = partition;
    fat->boot_sector = boot_sector;

    if (boot_sector->types.fat_12_16.boot_signature == 0x28 || 
        boot_sector->types.fat_12_16.boot_signature == 0x29
    ) {
        // now we know we are 12/16, find which one is it
        int root_dir_sectors = ((boot_sector->root_entry_count * 32) + boot_sector->bytes_per_sector - 1) / boot_sector->bytes_per_sector;
        int data_sectors = boot_sector->total_sectors_16bits - (boot_sector->reserved_sector_count + (boot_sector->sectors_per_fat_16 * boot_sector->number_of_fats) + root_dir_sectors);
        int data_clusters = data_sectors / boot_sector->sectors_per_cluster;

        // a fat16 cannot have less than 4085 clusters
        fat->fat_type = data_clusters < 4085 ? FAT12 : FAT16;
        klog_debug("FAT%d detected", fat->fat_type == FAT12 ? 12 : 16);

    } else if (boot_sector->types.fat_32.boot_signature == 0x28 ||
        boot_sector->types.fat_32.boot_signature == 0x29
    ) {
        klog_debug("FAT32 detected");
        fat->fat_type = FAT32;
    } else {
        klog_debug("Neither FAT12/16, nor FAT32, unsupported");
        kfree(fat);
        kfree(boot_sector);
        return ERR_NOT_SUPPORTED;
    }

    fat->bytes_per_sector = boot_sector->bytes_per_sector;
    fat->sectors_per_cluster = boot_sector->sectors_per_cluster;
    fat->bytes_per_cluster = fat->bytes_per_sector * fat->sectors_per_cluster;
    // round largest sector up to cluster boundary
    fat->largest_cluster_no = (partition->num_sectors + boot_sector->sectors_per_cluster - 1) / boot_sector->sectors_per_cluster;

    fat->sectors_per_fat = fat->fat_type == FAT32 ? 
        boot_sector->types.fat_32.sectors_per_fat_32 : 
        boot_sector->sectors_per_fat_16;

    fat->fat_starting_lba = 
        partition->first_sector + 
        boot_sector->reserved_sector_count;

    // on FAT12/16, the rood dir is fixed size, immediately after the FATs, data clusters start after that
    // on FAT32 we are given a specific cluster number, it resides in data clusters area
    uint32_t end_of_fats_lba = 
            partition->first_sector + 
            boot_sector->reserved_sector_count +
            (fat->sectors_per_fat * boot_sector->number_of_fats);
    uint32_t fat1216_root_dir_sectors_count = 
            (boot_sector->root_entry_count * 32) / boot_sector->bytes_per_sector;

    if (fat->fat_type == FAT12 || fat->fat_type == FAT16) {
        fat->data_clusters_starting_lba = end_of_fats_lba + fat1216_root_dir_sectors_count;
        fat->root_dir_starting_lba = end_of_fats_lba;
        fat->root_dir_sectors_count = fat1216_root_dir_sectors_count;
        fat->end_of_chain_value = fat->fat_type == FAT12 ? 0xFF8 : 0xFFF8;
    } else {
        fat->data_clusters_starting_lba = end_of_fats_lba;
        fat->root_dir_starting_lba =
            fat->data_clusters_starting_lba +
            (boot_sector->types.fat_32.root_dir_cluster - 2) * fat->sectors_per_cluster;
        fat->root_dir_sectors_count = fat->sectors_per_cluster; // no upper size limit actually
        fat->end_of_chain_value = 0x0FFFFFF8;
    }

    // setup operations for ease of use
    fat->ops = kmalloc(sizeof(struct fat_operations));
    memset(fat->ops, 0, sizeof(struct fat_operations));

    fat->ops->read_fat_sector = read_fat_sector;
    fat->ops->write_fat_sector = write_fat_sector;
    fat->ops->get_fat_entry_value = get_fat_entry_value;
    fat->ops->set_fat_entry_value = set_fat_entry_value;
    fat->ops->is_end_of_chain_entry_value = is_end_of_chain_entry_value;
    fat->ops->get_n_index_cluster_no = get_n_index_cluster_no;
    fat->ops->find_a_free_cluster = find_a_free_cluster;
    fat->ops->read_data_cluster = read_data_cluster;
    fat->ops->write_data_cluster = write_data_cluster;

    fat->ops->ensure_first_cluster_allocated = ensure_first_cluster_allocated;
    fat->ops->move_to_next_data_cluster = move_to_next_data_cluster;
    fat->ops->move_to_n_index_data_cluster = move_to_n_index_data_cluster;

    fat->ops->priv_file_open = priv_file_open;
    fat->ops->priv_file_read = priv_file_read;
    fat->ops->priv_file_write = priv_file_write;
    fat->ops->priv_file_seek = priv_file_seek;
    fat->ops->priv_file_close = priv_file_close;

    fat->ops->priv_dir_open_root = priv_dir_open_root;
    fat->ops->priv_dir_open_cluster = priv_dir_open_cluster;
    fat->ops->priv_dir_read_slot = priv_dir_read_slot;
    fat->ops->priv_dir_write_slot = priv_dir_write_slot;
    fat->ops->priv_dir_get_slot_no = priv_dir_get_slot_no;
    fat->ops->priv_dir_seek_slot = priv_dir_seek_slot;
    fat->ops->priv_dir_close = priv_dir_close;

    fat->ops->priv_dir_entry_read = priv_dir_entry_read;
    fat->ops->priv_dir_entry_invalidate = priv_dir_entry_invalidate;
    fat->ops->priv_dir_entry_update = priv_dir_entry_update;
    fat->ops->priv_dir_entry_append = priv_dir_entry_append;

    fat->ops->find_path_dir_entry = find_path_dir_entry;
    fat->ops->find_entry_in_dir = find_entry_in_dir;
    
    debug_fat_info(fat);

    // we should register something with the VFS or logical volume manager?
    partition->filesys_priv_data = fat;
    return SUCCESS;
}

struct file_ops fat_file_operations = {
    .opendir = fat_opendir,
    .readdir = fat_readdir,
    .closedir = fat_closedir,

    .open = fat_open,
    .read = fat_read,
    .write = fat_write,
    .seek = fat_seek,
    .close = fat_close
};

static struct file_ops *fat_get_file_operations() {
    return &fat_file_operations;
}
