#include <errors.h>
#include <klib/string.h>
#include "fat_priv.h"
#include "fat_dir_ops.cinl"
#include "fat_file_ops.cinl"

static int fat_probe(struct partition *partition) {
    klog_trace("FAT probing partition #%d (legacy type 0x%02x)", partition->part_no, partition->legacy_type);

    if (sizeof(fat_boot_sector_t) != 512) {
        klog_error("Boot sector struct would not align with reading of a sector");
        return ERR_NOT_SUPPORTED;
    }
    
    // let's check the first sector of the partition.
    fat_boot_sector_t *boot_sector = kmalloc(sizeof(fat_boot_sector_t));
    memset(boot_sector, 0, sizeof(fat_boot_sector_t));
    int err = partition->dev->ops->read(
        partition->dev, 
        partition->first_sector, 0,
        1,
        (char *)boot_sector
    );
    if (err) {
        klog_debug("Err %d reading first sector of partition", err);
        kfree(boot_sector);
        return err;
    }
    
    if (boot_sector->bootjmp[0] != 0xEB ||
        boot_sector->bytes_per_sector != 512 ||
        boot_sector->number_of_fats != 2 ||
        (boot_sector->total_sectors_16bits == 0 && boot_sector->total_sectors_32bits == 0) ||
        (
            boot_sector->types.fat_12_16.boot_signature != 0x28 &&
            boot_sector->types.fat_12_16.boot_signature != 0x29 && 
            boot_sector->types.fat_32.boot_signature != 0x28 &&
            boot_sector->types.fat_32.boot_signature != 0x29
        ) ||
        boot_sector->bootable_sector_signature != 0xAA55
    ) {
        klog_debug("Does not look like a FAT MBR");
        kfree(boot_sector);
        return ERR_NOT_SUPPORTED;
    }

    struct fat_info *info = kmalloc(sizeof(struct fat_info));
    memset(info, 0, sizeof(struct fat_info));
    info->partition = partition;
    info->boot_sector = boot_sector;

    if (boot_sector->types.fat_12_16.boot_signature == 0x28 || 
        boot_sector->types.fat_12_16.boot_signature == 0x29
    ) {
        // now we know we are 12/16, find which one is it
        int root_dir_sectors = ((boot_sector->root_entry_count * 32) + boot_sector->bytes_per_sector - 1) / boot_sector->bytes_per_sector;
        int data_sectors = boot_sector->total_sectors_16bits - (boot_sector->reserved_sector_count + (boot_sector->sectors_per_fat_16 * boot_sector->number_of_fats) + root_dir_sectors);
        int data_clusters = data_sectors / boot_sector->sectors_per_cluster;

        // a fat16 cannot have less than 4085 clusters
        info->fat_type = data_clusters < 4085 ? FAT12 : FAT16;
        klog_debug("FAT%d detected", info->fat_type == FAT12 ? 12 : 16);

    } else if (boot_sector->types.fat_32.boot_signature == 0x28 ||
        boot_sector->types.fat_32.boot_signature == 0x29
    ) {
        klog_debug("FAT32 detected");
        info->fat_type = FAT32;
    } else {
        klog_debug("Neither FAT12/16, nor FAT32, unsupported");
        kfree(info);
        kfree(boot_sector);
        return ERR_NOT_SUPPORTED;
    }

    info->bytes_per_sector = boot_sector->bytes_per_sector;
    info->sectors_per_cluster = boot_sector->sectors_per_cluster;
    info->bytes_per_cluster = info->bytes_per_sector * info->sectors_per_cluster;
    // round largest sector up to cluster boundary
    info->largest_cluster_no = (partition->num_sectors + boot_sector->sectors_per_cluster - 1) / boot_sector->sectors_per_cluster;


    info->sectors_per_fat = info->fat_type == FAT32 ? 
        boot_sector->types.fat_32.sectors_per_fat_32 : 
        boot_sector->sectors_per_fat_16;

    info->fat_starting_lba = 
        partition->first_sector + 
        boot_sector->reserved_sector_count;

    // on FAT12/16, the rood dir is fixed size, immediately after the FATs, data clusters start after that
    // on FAT32 we are given a specific cluster number, it resides in data clusters area
    uint32_t end_of_fats_lba = 
            partition->first_sector + 
            boot_sector->reserved_sector_count +
            (info->sectors_per_fat * boot_sector->number_of_fats);
    uint32_t fat1216_root_dir_sectors_size = 
            (boot_sector->root_entry_count * 32) / boot_sector->bytes_per_sector;

    if (info->fat_type == FAT12 || info->fat_type == FAT16) {
        info->data_clusters_starting_lba = end_of_fats_lba + fat1216_root_dir_sectors_size;
        info->root_dir_starting_lba = end_of_fats_lba;
        info->root_dir_sectors_size = fat1216_root_dir_sectors_size;
    } else {
        info->data_clusters_starting_lba = end_of_fats_lba;
        info->root_dir_starting_lba =
            info->data_clusters_starting_lba +
            (boot_sector->types.fat_32.root_dir_cluster - 2) * info->sectors_per_cluster;
        info->root_dir_sectors_size = info->sectors_per_cluster;
    }

    partition->filesys_priv_data = info;
    debug_fat_info(info);

    // we should register something with the VFS or logical volume manager?
    partition->filesys_priv_data = info;
    return SUCCESS;
}

struct file_ops fat_file_operations = {
    .opendir = fat_opendir,
    .readdir = fat_readdir,
    .closedir = fat_closedir,

    .open = fat_open,
    .read = fat_read,
    .seek = fat_seek,
    .close = fat_close
};

static struct file_ops *fat_get_file_operations() {
    return &fat_file_operations;
}
