#ifndef _FAT_FILE_OPS_CINL
#define _FAT_FILE_OPS_CINL

#include <filesys/vfs.h>
#include <memory/kheap.h>
#include <klib/string.h>
#include <klog.h>
#include <errors.h>
#include "fat_priv.h"
#include <lock.h>

#define min(a, b)                ((a) <= (b) ? (a) : (b))
#define max(a, b)                ((a) >= (b) ? (a) : (b))
#define between(value, lo, hi)   (max(min((value), (hi)), (lo)))

lock_t fat_write_lock;


static uint32_t calculate_new_file_offset(file_t *file, int offset, enum seek_origin origin) {
    uint32_t old_position = ((struct fat_priv_file_info *)file->filesys_priv_data)->offset;
    uint32_t size = ((struct fat_priv_file_info *)file->filesys_priv_data)->size;
    uint32_t new_position = old_position;
    uint32_t positive_offset = (offset >= 0) ? (uint32_t)offset : (uint32_t)(offset * -1);


    if (origin == SEEK_START) {
        if (offset >= 0)
            new_position = min(positive_offset, size);
        else if (offset < 0)
            new_position = 0;

    } else if (origin == SEEK_END) { 
        if (offset >= 0)
            new_position = size;
        else if (offset < 0)
            new_position = size - min(positive_offset, size);

    } else if (origin == SEEK_CURRENT) {
        if (offset >= 0)
            new_position = min(old_position + offset, size);
        else if (offset < 0)
            new_position = old_position - min(positive_offset, old_position);
    }

    klog_trace("calculate_new_file_offset(ofs=%d, ori=%d, pos=%d, siz=%d) --> %d",
        offset,
        origin,
        old_position,
        size,
        new_position
    );
    return new_position;
}

static int fat_open(char *path, file_t *file) {
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;

    struct fat_priv_file_info *pf = kmalloc(sizeof(struct fat_priv_file_info));
    memset(pf, 0, sizeof(struct fat_priv_file_info));
    pf->dir_entry = kmalloc(sizeof(struct fat_dir_entry));
    memset(pf->dir_entry, 0, sizeof(struct fat_dir_entry));
    pf->sector = kmalloc(sizeof(struct sector));
    memset(pf->sector, 0, sizeof(struct sector));
    pf->cluster = kmalloc(sizeof(struct cluster));
    memset(pf->cluster, 0, sizeof(struct cluster));
    pf->sector->buffer = kmalloc(fat->bytes_per_sector);
    memset(pf->sector->buffer, 0, fat->bytes_per_sector);
    pf->cluster->buffer = kmalloc(fat->bytes_per_cluster);
    memset(pf->cluster->buffer, 0, fat->bytes_per_cluster);

    file->filesys_priv_data = pf;

    klog_trace("fat_open(fat_type=FAT%d, path=\"%s\")", 
        fat->fat_type == FAT32 ? 32 : (fat->fat_type == FAT16 ? 16 : 12), 
        path);

    // follow the path to the dir first
    int err = find_entry_for_path(file, path, pf->dir_entry);
    if (err)
        return err;
    if (pf->dir_entry->attributes.flags.directory ||
        pf->dir_entry->attributes.flags.volume_label)
        return ERR_NOT_A_FILE;
    klog_debug("File directory entry");
    debug_fat_dir_entry(true, NULL);
    debug_fat_dir_entry(false, pf->dir_entry);

    // read the first cluster, to prepare for reading
    err = fat->ops->read_data_cluster(fat, pf->dir_entry->first_cluster_no, pf->cluster);
    if (err)
        return err;
    klog_debug("File cluster contents");
    klog_hex16_debug(pf->cluster->buffer, fat->bytes_per_cluster, 0);
    
    pf->cluster_n_index = 0;
    pf->first_cluster_no = pf->dir_entry->first_cluster_no;
    pf->size = pf->dir_entry->file_size;
    pf->offset = 0;
    
    return SUCCESS;
}

static int fat_read(file_t *file, char *buffer, int length) {
    klog_trace("fat_read(length=%d)", length);
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *pf = (struct fat_priv_file_info *)file->filesys_priv_data;
    int bytes_actually_read = 0;
    int err;

    length = max(length, 0);
    if (length == 0)
        return SUCCESS;
    
    // don't allow reading past EOF
    if (pf->offset + length > pf->size)
        length = pf->size - pf->offset;
    
    while (true) {
        // copy what we can from the current cluster
        int offset_in_cluster = pf->offset - (pf->cluster_n_index * fat->bytes_per_cluster);
        int available_in_cluster = fat->bytes_per_cluster - offset_in_cluster;
        int chunk_len = min(length, available_in_cluster);
        memcpy(buffer + bytes_actually_read, pf->cluster->buffer + offset_in_cluster, chunk_len);
        bytes_actually_read += chunk_len;
        length -= chunk_len;
        pf->offset += chunk_len;
        if (length == 0)
            break;

        if (pf->offset < pf->size && length > 0) {
            // we need to load next cluster
            err = fat->ops->move_to_next_data_cluster(fat, pf, false);
            if (err) return err;
        }
    }

    // instead of success, we return the bytes we actually read
    return bytes_actually_read;
}

static int fat_write(file_t *file, char *buffer, int length) {
    klog_trace("fat_write(length=%d)", length);
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *pf = (struct fat_priv_file_info *)file->filesys_priv_data;
    int bytes_actually_written = 0;
    int err = 0;

    length = max(length, 0);
    if (length == 0)
        return SUCCESS;
    
    // avoid return, to make sure we unlock this
    acquire(&fat_write_lock);

    // ensure there is a cluster to write, even a first one, for new files
    fat->ops->ensure_first_cluster_allocated(fat, pf);

    while (true) {
        // copy what we can into the current cluster
        int offset_in_cluster = pf->offset - (pf->cluster_n_index * fat->bytes_per_cluster);
        int remaining_in_cluster = fat->bytes_per_cluster - offset_in_cluster;
        int chunk_len = min(length, remaining_in_cluster);

        memcpy(pf->cluster->buffer + offset_in_cluster, buffer + bytes_actually_written, chunk_len);
        pf->cluster->dirty = true;
        bytes_actually_written += chunk_len;
        pf->offset += chunk_len;
        pf->size = max(pf->size, pf->offset);

        length -= chunk_len;
        if (length == 0)
            goto exit;

        // move to next cluster, writing this if dirty
        err = fat->ops->move_to_next_data_cluster(fat, pf, true);
        if (err)
            goto exit;
    }

exit:
    release(&fat_write_lock);
    return err ? err : bytes_actually_written;
}

static int fat_seek(file_t *file, int offset, enum seek_origin origin) {
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *pf = (struct fat_priv_file_info *)file->filesys_priv_data;
    int err;

    klog_trace("fat_seek(offset=%d, origin=%d)", offset, origin);
    uint32_t final_position = calculate_new_file_offset(file, offset, origin);
    uint32_t cluster_n_index = final_position / fat->bytes_per_cluster;
    
    err = fat->ops->move_to_n_index_data_cluster(fat, pf, cluster_n_index);
    if (err) return err;

    pf->offset = final_position;
    return (int)final_position;
}

static int fat_close(file_t *file) {
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *pf = (struct fat_priv_file_info *)file->filesys_priv_data;

    // possibly write any current cluster if dirty
    if (pf->cluster->cluster_no > 0 && pf->cluster->dirty) {
        int err = fat->ops->write_data_cluster(fat, pf->cluster);
        if (err)
            return err;
    }

    // we must free what we allocated in open()
    kfree(pf->sector->buffer);
    kfree(pf->sector);
    kfree(pf->cluster->buffer);
    kfree(pf->cluster);
    kfree(pf->dir_entry);
    kfree(pf);

    return SUCCESS;
}

static int fat_touch(char *path, file_t *file) {
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *pf = (struct fat_priv_file_info *)file->filesys_priv_data;
    int err = ERR_NOT_IMPLEMENTED;
    
    return err;
}

static int fat_unlink(char *path, file_t *file) {
    struct fat_info *fat = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *pf = (struct fat_priv_file_info *)file->filesys_priv_data;
    int err = ERR_NOT_IMPLEMENTED;
    
    return err;
}


#endif
