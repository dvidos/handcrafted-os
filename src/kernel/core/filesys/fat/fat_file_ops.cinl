#ifndef _FAT_FILE_OPS_CINL
#define _FAT_FILE_OPS_CINL

#include <filesys/vfs.h>
#include <memory/kheap.h>
#include <klib/string.h>
#include <klog.h>
#include <errors.h>
#include "fat_priv.h"



static int fat_open(char *path, file_t *file) {
    struct fat_info *fat_info = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *file_info = kmalloc(sizeof(struct fat_priv_file_info));
    memset(file_info, 0, sizeof(struct fat_priv_file_info));
    file->driver_priv_data = file_info;
    file_info->cluster_buffer = kmalloc(fat_info->bytes_per_cluster);
    file_info->dir_entry = kmalloc(sizeof(struct fat_dir_entry));
    klog_trace("fat_opendir(fat_type=FAT%d, path=\"%s\")", 
        fat_info->fat_type == FAT32 ? 32 : (fat_info->fat_type == FAT16 ? 16 : 12), 
        path);

    file_info->is_root_directory = (strlen(path) == 1 && *path == '/');
    if (file_info->is_root_directory)
    {
        if (fat_info->fat_type == FAT12 || fat_info->fat_type == FAT16) {
            return fat16_root_dir_open(file);
        } else {
            // tested and works
            return dir_in_data_clusters_open(file, fat_info->boot_sector->types.fat_32.root_dir_cluster);
        }
    }
    else
    {
        // follow the path to the dir first
        int err = find_entry_for_path(file, path, file_info->dir_entry);
        if (err)
            return err;
        if (!file_info->dir_entry->attributes.flags.directory)
            return ERR_NOT_A_DIRECTORY;
        return dir_in_data_clusters_open(file, file_info->dir_entry->first_cluster_no);
    }
}

static int fat_read(file_t *file, char *buffer, int length) {
    return ERR_NOT_IMPLEMENTED;
}

static int fat_seek(file_t *file, int position, enum seek_origin origin) {
    return ERR_NOT_IMPLEMENTED;
}

static int fat_close(file_t *file) {
    struct fat_info *fat_info = (struct fat_info *)file->partition->filesys_priv_data;
    struct fat_priv_file_info *file_info = (struct fat_priv_file_info *)file->driver_priv_data;
    int err;

    if (file_info->is_root_directory && (fat_info->fat_type == FAT12 || fat_info->fat_type == FAT16))
        err = fat16_root_dir_close(file);
    else
        err = dir_in_data_clusters_close(file);

    // we must free what we allocated in open()
    kfree(file_info->cluster_buffer);
    kfree(file_info->dir_entry);
    kfree(file_info);
    return err;
}


#endif