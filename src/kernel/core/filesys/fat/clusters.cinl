#include "fat_priv.h"
#include <errors.h>


static int read_fat_sector(struct fat_info *info, uint32_t sector_no, struct sector *sector) {
    int err = info->partition->dev->ops->read(info->partition->dev,
        info->fat_starting_lba + sector_no, 0,
        1, sector->buffer
    );
    if (err == 0) {
        sector->sector_no = sector_no;
        sector->dirty = false;
    }
    klog_trace("read_fat_sector(sector=%d) -> %d", sector_no, err);
    return err;
}

static int write_fat_sector(struct fat_info *info, struct sector *sector) {
    int err = info->partition->dev->ops->write(info->partition->dev,
        info->fat_starting_lba + sector->sector_no, 0,
        1, sector->buffer
    );
    klog_trace("write_fat_sector(sector=%d) -> %d", sector->sector_no, err);
    if (err == 0) {
        sector->dirty = false;
    }
    return err;
}

static int get_fat_entry_value(struct fat_info *info, struct sector *sector, uint32_t cluster_no, uint32_t *value) {
    klog_trace("get_fat_entry_value(cluster=%d)", cluster_no);
    uint32_t offset_in_fat;
    if (info->fat_type == FAT12) {
        // multiply by 1.5 <==> 1 + (1/2), (rounding down err correction later)
        offset_in_fat = cluster_no + (cluster_no / 2);
    } else if (info->fat_type == FAT16) {
        offset_in_fat = cluster_no * 2; // two bytes for 16 bits
    } else if (info->fat_type == FAT32) {
        offset_in_fat = cluster_no * 4; // four bytes for 32 bits
    } else {
        return ERR_NOT_SUPPORTED;
    }

    // find the sector of FAT to load and load it.
    uint32_t fat_sector_no    = offset_in_fat / info->bytes_per_sector;
    uint32_t offset_in_sector = offset_in_fat % info->bytes_per_sector;

    if (sector->sector_no != fat_sector_no) {
        int err = read_fat_sector(info, fat_sector_no, sector);
        if (err)
            return err;
    }

    // now that we have the sector, extract the next cluster_no
    if (info->fat_type == FAT12) {
        uint16_t word = *(uint16_t *)(sector->buffer + offset_in_sector);

        // see if we rounded down (when we divided by two)
        if (cluster_no & 0x0001)
            word >>= 4;    // use three higher nibbles (out of the four)
        else
            word &= 0xFFF; // use three lower nibbles (out of the four)

        *value = word;
    } else if (info->fat_type == FAT16) {
        *value = *(uint16_t *)(sector->buffer + offset_in_sector);

    } else if (info->fat_type == FAT32) {
        *value = 
            (*(uint32_t *)(sector->buffer + offset_in_sector))
            & 0x0FFFFFFF; // ignore four upper bits

    } else {
        return ERR_NOT_SUPPORTED;
    }

    klog_trace("get_fat_entry_value(cluster=%d, new_value=%d)", cluster_no, *value);
    return SUCCESS;
}

static int set_fat_entry_value(struct fat_info *info, struct sector *sector, uint32_t cluster_no, uint32_t value) {
    klog_trace("set_fat_entry_value(cluster=%d, value=%d)", cluster_no, value);
    uint32_t offset_in_fat;
    if (info->fat_type == FAT12) {
        // multiply by 1.5 <==> 1 + (1/2), (rounding down err correction later)
        offset_in_fat = cluster_no + (cluster_no / 2);
    } else if (info->fat_type == FAT16) {
        offset_in_fat = cluster_no * 2; // two bytes for 16 bits
    } else if (info->fat_type == FAT32) {
        offset_in_fat = cluster_no * 4; // four bytes for 32 bits
    } else {
        return ERR_NOT_SUPPORTED;
    }

    // find the sector of FAT to load and load it.
    uint32_t fat_sector_no    = offset_in_fat / info->bytes_per_sector;
    uint32_t offset_in_sector = offset_in_fat % info->bytes_per_sector;

    if (sector->sector_no != fat_sector_no) {
        int err = read_fat_sector(info, fat_sector_no, sector);
        if (err)
            return err;
    }

    // now that we have the sector, set the value
    if (info->fat_type == FAT12) {
        uint16_t word = *(uint16_t *)(sector->buffer + offset_in_sector);

        // see if we rounded down (when we divided by two)
        if (cluster_no & 0x0001)
            word = (word & 0x000F) | ((value & 0xFFF) << 4);    // use three higher nibbles (out of the four)
        else
            word = (word & 0xF000) | (value & 0xFFF); // use three lower nibbles (out of the four)

        *(uint16_t *)(sector->buffer + offset_in_sector) = word;
    } else if (info->fat_type == FAT16) {
        *(uint16_t *)(sector->buffer + offset_in_sector) = value;

    } else if (info->fat_type == FAT32) {
        // clear four upper bits
        *(uint32_t *)(sector->buffer + offset_in_sector) = value & 0x0FFFFFFF;

    } else {
        return ERR_NOT_SUPPORTED;
    }

    sector->dirty = true;
    return SUCCESS;
}

static bool is_end_of_chain_entry_value(struct fat_info *info, uint32_t value) {
    return value == info->end_of_chain_value || value > info->largest_cluster_no;
}

static int find_a_free_cluster(struct fat_info *info, struct sector *sector, uint32_t *cluster_no) {
    klog_trace("find_a_free_cluster()");
    uint32_t value;
    for (uint32_t cl = 2; cl < info->largest_cluster_no; cl++) {
        int err = get_fat_entry_value(info, sector, cl, &value);
        if (err)
            return err;
        if (value == 0) {
            *cluster_no = cl;
            klog_trace("find_a_free_cluster(free_cluster=%d)", *cluster_no);
            return SUCCESS;
        }
    }

    return ERR_NO_SPACE_LEFT;
}

static int get_n_index_cluster_no(struct fat_info *info, struct sector *sector, uint32_t first_cluster, uint32_t cluster_n_index, uint32_t *cluster_no) {
    klog_trace("get_n_index_cluster_no(cluster_n_index=%d)", cluster_n_index);

    uint32_t curr_cluster_no = first_cluster;
    uint32_t value = 0;
    while (cluster_n_index-- > 0) {
        int err = get_fat_entry_value(info, sector, curr_cluster_no, &value);
        if (err)
            return err;
        curr_cluster_no = value;
    }

    *cluster_no = curr_cluster_no;
    return SUCCESS;
}

static int read_data_cluster(struct fat_info *info, uint32_t cluster_no, struct cluster *cluster) {
    int err = info->partition->dev->ops->read(
        info->partition->dev,
        info->data_clusters_starting_lba + ((cluster_no - 2) * info->sectors_per_cluster),
        0,
        info->sectors_per_cluster,
        cluster->buffer
    );
    if (err == 0) {
        cluster->cluster_no = cluster_no;
        cluster->dirty = false;
    }
    klog_trace("read_data_cluster(cluster=%d) --> %d", cluster_no, err);
    return err;
}

static int write_data_cluster(struct fat_info *info, struct cluster *cluster) {
    int err = info->partition->dev->ops->write(
        info->partition->dev,
        info->data_clusters_starting_lba + ((cluster->cluster_no - 2) * info->sectors_per_cluster),
        0,
        info->sectors_per_cluster,
        cluster->buffer
    );
    if (err == 0) {
        cluster->dirty = false;
    }
    klog_trace("write_data_cluster(cluster=%d) --> %d", cluster->cluster_no, err);
    return err;
}


